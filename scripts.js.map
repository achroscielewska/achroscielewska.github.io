{"version":3,"sources":["src/assets/externalLib/circularSlider.js","node_modules/document-register-element/build/document-register-element.js"],"names":[],"mappings":"AAAA;AACA;;AAEA,sLAAsL,+BAA+B;AACrN,mHAAmH,yBAAyB;;AAE5I;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA,yEAAyE,sCAAsC;AAC/G;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb,6CAA6C;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qEAAqE,sCAAsC;AAC3G,SAAS;AACT;AACA;;AAEA;AACA,yEAAyE,sCAAsC;AAC/G;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2DAA2D,mBAAmB,GAAG,mBAAmB;AACpG,4DAA4D,mBAAmB;;AAE/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D,6CAA6C,2BAA2B;AACxE,4CAA4C,eAAe;AAC3D;AACA;AACA,2FAA2F;;AAE3F;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;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","file":"scripts.js","sourcesContent":["// Copyright (c) 2018 Matic Balantič\r\n// Licensed under the MIT license.\r\n\r\nwindow.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(f){return setTimeout(f, 1000/60)}; // simulate calling code 60\r\nwindow.cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || function(requestID){clearTimeout(requestID)}; //fall back\r\n\r\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\r\n\r\nconst _validateOptions = Symbol('validateOptions');\r\nconst _init = Symbol('init');\r\nconst _isIEorEdge = Symbol('isIEorEdge');\r\nconst _createRootSVG = Symbol('createRootSVG');\r\nconst _initSlider = Symbol(\"addSliderToRootSVG\");\r\nconst _createSliderCircle = Symbol('createSliderCircle');\r\nconst _createEmptyCircle = Symbol('createEmptyCircle');\r\nconst _createClickCircle = Symbol('createClickCircle');\r\nconst _createCircle = Symbol('createSlider');\r\nconst _createHandle = Symbol('createHandle');\r\nconst _deg2Step = Symbol('deg2Step');\r\nconst _step2Rad = Symbol('step2Rad');\r\nconst _val2Step = Symbol('_val2Step');\r\nconst _deg2Val = Symbol('deg2Val');\r\nconst _point2Radians = Symbol('point2Radians');\r\nconst _setStepFallback = Symbol('setStepFallback');\r\nconst _move = Symbol('move');\r\nconst _canMove = Symbol('cantMove');\r\nconst _updateState = Symbol(\"updateState\");\r\nconst _cancelDrag = Symbol('cancelDrag');\r\nconst _startDrag = Symbol('startDrag');\r\nconst _handleDrag = Symbol('handleDrag');\r\nconst _handleSliderClick = Symbol('handleSlideClick');\r\nconst _initEventHandlers = Symbol('initEventHandlers');\r\nconst _touchHandler = Symbol('touchHandler');\r\nconst _calculateNewPosition = Symbol('calculateNewPoint');\r\nconst _transformClientToLocalCoordinate = Symbol('transformClientToLocalCoordinate');\r\n\r\nconst STROKE_WIDTH = 20;\r\nconst HANDLER_RADIUS = (STROKE_WIDTH / 2) + 6;\r\nconst TOLERANCE = 40;\r\n\r\n\r\n\r\nclass CircularSlider {\r\n    constructor(id, options) {\r\n        this.options = options;\r\n        this.id = id;\r\n\r\n        this[_validateOptions]();\r\n        this[_init]();\r\n    }\r\n\r\n    /**\r\n     * Returns the current value which can only be a number divisible by step.\r\n     *\r\n     * @returns {number}\r\n     */\r\n    get currentValue() {\r\n\r\n        return this.options.min + (this.currentStepNo * this.options.step)\r\n    }\r\n\r\n    /**\r\n     * Sets slider value based on the provided step number. We don't allow setting the value directly since\r\n     * it can only be set to numbers divisible by step (this.options.step).\r\n     *\r\n     * @param stepNo\r\n     */\r\n    set stepNo(stepNo) {\r\n        const maxSteps = (this.options.max - this.options.min) / this.options.step;\r\n        if (isNaN(parseFloat(stepNo)) || stepNo < 0 || stepNo > maxSteps) {\r\n            throw new Error(\"Step number \" + stepNo + \" is not between 0 and \" + maxSteps);\r\n        }\r\n\r\n        if (this.isIEorEdge) {\r\n            this[_setStepFallback](stepNo);\r\n        } else {\r\n            const radiansEnd = this[_step2Rad](stepNo);\r\n            const newPosition = this[_calculateNewPosition](radiansEnd);\r\n\r\n            this.slider.style.transition = \"stroke-dashoffset 0.5s ease-in-out\";\r\n            this.handle.style.transition = \"all 0.5s ease-in-out\";\r\n\r\n            requestAnimationFrame(() => {\r\n                this.slider.setAttributeNS(null, 'stroke-dashoffset', `${this.circumference - newPosition.path}`);\r\n                this.handle.style.transform = \"rotate(\" + newPosition.degrees + \"deg)\";\r\n                this[_updateState](newPosition, stepNo);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Used for Edge/IE because of it doesn't support SVG animation via CSS. :/\r\n     * Animates slider by setting stroke-dashoffset and transform properties in a requestAnimationFrame loop.\r\n     *\r\n     * @param stepNo\r\n     */\r\n    [_setStepFallback](stepNo) {\r\n        //stop current animation if in progress\r\n        if (this.animationFrameId !== null) {\r\n            cancelAnimationFrame(this.animationFrameId);\r\n            this.animationFrameId = null;\r\n        }\r\n\r\n        // calculate start/end points\r\n        const radiansStart = this.position.radians;\r\n        const radiansEnd = this[_step2Rad](stepNo);\r\n        const isIncreasing = radiansStart < radiansEnd;\r\n        let radiansMove = radiansStart;\r\n\r\n        const animate = () => {\r\n            // add easing if we are close to end of the step\r\n            radiansMove += (Math.abs(radiansEnd - radiansMove) <= 0.2) ? (isIncreasing ? 0.01 : -0.01) : (isIncreasing ? 0.05 : -0.05);\r\n\r\n            this[_move](radiansMove);\r\n\r\n            // allow for a small error because of the rounding\r\n            if ((Math.abs(radiansMove - radiansEnd) > 0.01)) {\r\n                this.animationFrameId = requestAnimationFrame(animate);\r\n            } else {\r\n                this.animationFrameId = null; // animation ended\r\n            }\r\n        };\r\n\r\n        this.animationFrameId = requestAnimationFrame(animate);\r\n    }\r\n\r\n    /**\r\n     * Moves slider on the orbit for the given coordinates.\r\n     *\r\n     * @param angelRadians\r\n     */\r\n    [_move](angelRadians) {\r\n\r\n        const newPosition = this[_calculateNewPosition](angelRadians);\r\n        if (!this[_canMove](newPosition)) {\r\n            return;\r\n        }\r\n\r\n        const nextStep = this[_deg2Step](newPosition.degrees);\r\n        this[_updateState](newPosition, nextStep);\r\n\r\n        if (this.isIEorEdge) {\r\n            const transform = 'rotate(' + newPosition.degrees + ')';\r\n\r\n            this.handle.setAttributeNS(null, 'transform', transform);\r\n            this.slider.setAttributeNS(null, 'stroke-dashoffset', `${this.circumference - newPosition.path}`);\r\n        } else {\r\n            this.slider.style.transition = \"\";\r\n            this.handle.style.transition = \"\";\r\n\r\n            requestAnimationFrame(() => {\r\n                this.slider.setAttributeNS(null, 'stroke-dashoffset', `${this.circumference - newPosition.path}`);\r\n                this.handle.style.transform = \"rotate(\" + newPosition.degrees + \"deg)\";\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns false if slider wants to be moved past the top zero point.\r\n     *\r\n     * @param newPosition\r\n     * @returns {boolean}\r\n     */\r\n    [_canMove](newPosition) {\r\n        return !(this.position.y < 0 && ((this.position.x >= 0 && newPosition.x < 0) || (this.position.x < 0 && newPosition.x >= 0)));\r\n    }\r\n\r\n    /**\r\n     * Calculates new position, angles and path traveled based on local coordinate system (center = 0,0).\r\n     *\r\n     * @param angleRadians\r\n     * @returns {{x: number, y: number, degrees: number, radians: number, path: number}}\r\n     */\r\n    [_calculateNewPosition](angleRadians) {\r\n        const newX = Math.round(Math.sin(angleRadians) * this.radius);\r\n        const newY = Math.round(Math.cos(angleRadians) * this.radius) * -1;\r\n\r\n        // we have our coordinates right, but angles need to be adjusted to positive number\r\n        // basically just add 2PI - 360 degrees\r\n        const radians360 = angleRadians < 0 ? angleRadians + 2 * Math.PI : angleRadians;\r\n        const angelDegrees = radians360 * 180.0 / Math.PI;\r\n        const path = Math.round(this.radius * radians360);\r\n\r\n        return {\r\n            x: Math.floor(angelDegrees) === 359 ? -1 : newX,\r\n            y: newY,\r\n            degrees: angelDegrees,\r\n            radians: radians360,\r\n            path: path\r\n        };\r\n    }\r\n\r\n    [_updateState](newPosition, nextStep) {\r\n        // notify about value change\r\n        if (this.currentStepNo !== nextStep && (this.options.valueChange && typeof(this.options.valueChange) === 'function')) {\r\n            this.currentStepNo = nextStep; // set step here so we send the latest value\r\n\r\n            this.options.valueChange(this.currentValue, this.options.eventType);\r\n            this.options.eventType = '';\r\n        }\r\n\r\n        // update slider internal state\r\n        this.value = this[_deg2Val](newPosition.degrees);\r\n        this.currentStepNo = nextStep;\r\n        this.position = newPosition;\r\n    }\r\n\r\n    [_validateOptions]() {\r\n        const step = this.options.step;\r\n        const min = this.options.min;\r\n        const max = this.options.max;\r\n\r\n        if (min > max) {\r\n            throw new Error(\"Min \" + min + \" must be smaller than max \" + max + \"!\");\r\n        }\r\n\r\n        if (max % step !== 0 || min % step !== 0) {\r\n            throw new Error(\"Min \" + min + \" and max \" + max + \" + must be divisible by step \" + step + \"!\");\r\n        }\r\n\r\n        if (this.options.radius > 200 || this.options.radius < 0) {\r\n            throw new Error(\"Radius must be between 1 and 200. The slider will adjust the to the size of the container automatically. Radius 200 means slider will be touching the boundaries\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes (calculates values of) all properties and creates a slider.\r\n     */\r\n    [_init]() {\r\n        this.isIEorEdge = this[_isIEorEdge](); // cache the result since we'll be checking it very often\r\n        this.centerX = 0;\r\n        this.centerY = 0;\r\n        this.radius = this.options.radius - (STROKE_WIDTH / 2); // subtract border width from radius\r\n        this.circumference = this.options.radius * 2 * Math.PI;\r\n        this.currentStepNo = 0;\r\n        this.isDragging = false;\r\n        this.position = this[_calculateNewPosition](this.centerX, this.centerY - this.radius);\r\n        this.value = this.options.min;\r\n\r\n        this.lastTouchType = '';\r\n        this.animationFrameId = null;\r\n\r\n        this[_initSlider]();\r\n        this[_initEventHandlers]();\r\n    }\r\n\r\n    /**\r\n     * Creates slider composed of underlying stripped SVG circle and top colored circle which will behave as slider.\r\n     */\r\n    [_initSlider]() {\r\n        this.container = document.getElementById(this.options.container);\r\n\r\n        // create root svg only when the first slider is added to the container.\r\n        this.rootSVG = document.getElementById(this.id);\r\n        if (this.rootSVG === null) {\r\n            this.rootSVG = this[_createRootSVG](this.container.offsetWidth);\r\n            this.container.appendChild(this.rootSVG);\r\n        }\r\n\r\n        this.slider = this[_createSliderCircle]();\r\n        this.handle = this[_createHandle]();\r\n        this.clickCircle = this[_createClickCircle]();\r\n\r\n        this.rootSVG.appendChild(this[_createEmptyCircle]());\r\n        this.rootSVG.appendChild(this.clickCircle);\r\n        this.rootSVG.appendChild(this.slider);\r\n        this.rootSVG.appendChild(this.handle);\r\n    }\r\n\r\n    /**\r\n     * Creates root svg to which all sliders residing in the same container are later appended.\r\n     * @returns {SVGCircleElement}\r\n     */\r\n    [_createRootSVG](boxSize) {\r\n        const svg = document.createElementNS(SVG_NAMESPACE, \"svg\");\r\n\r\n\r\n        // let's keep it a square\r\n        svg.setAttributeNS(null, \"class\", \"sliderRootSVG\");\r\n        svg.setAttributeNS(null, \"id\", this.id);\r\n        svg.setAttributeNS(null, \"width\", boxSize);\r\n        svg.setAttributeNS(null, \"height\", boxSize);\r\n        svg.setAttributeNS(null, \"viewBox\", \"-200 -200 400 400\");\r\n        svg.setAttributeNS(null, \"preserveAspectRatio\", \"xMidYMid none\");\r\n\r\n        return svg;\r\n    }\r\n\r\n    [_transformClientToLocalCoordinate](svgPoint, event) {\r\n        svgPoint.x = event.clientX;\r\n        svgPoint.y = event.clientY;\r\n\r\n        return svgPoint.matrixTransform(this.rootSVG.getScreenCTM().inverse());\r\n    }\r\n\r\n    /**\r\n     * Creates new SVG circle used as a top slider.\r\n     */\r\n    [_createSliderCircle]() {\r\n        const slider = this[_createCircle]();\r\n\r\n        slider.setAttributeNS(null, 'class', 'top-slider');\r\n        slider.setAttributeNS(null, 'transform', 'rotate(-90)');\r\n        slider.setAttributeNS(null, 'stroke-dasharray', `${this.circumference} ${this.circumference}`);\r\n        slider.setAttributeNS(null, 'stroke-dashoffset', `${this.circumference}`);\r\n\r\n        slider.style.stroke = this.options.color;\r\n        slider.style.strokeWidth = STROKE_WIDTH + \"px\";\r\n\r\n        return slider;\r\n    }\r\n\r\n    /**\r\n     * Creates transparent circle so we can click on it (dashed border is not click-able everywhere)\r\n     * @returns SVG\r\n     */\r\n    [_createClickCircle]() {\r\n        const slider = this[_createCircle]();\r\n\r\n        slider.style.strokeWidth = STROKE_WIDTH + \"px\";\r\n        slider.style.stroke = \"transparent\";\r\n\r\n        return slider;\r\n    }\r\n\r\n    /**\r\n     * Creates new SVG circle with dashed border used as empty \"underlying\" slider.\r\n     */\r\n    [_createEmptyCircle]() {\r\n        const slider = this[_createCircle]();\r\n\r\n        slider.setAttributeNS(null, 'class', 'dashed-circle');\r\n        slider.setAttributeNS(null, 'transform', 'rotate(-90)');\r\n        slider.style.strokeWidth = STROKE_WIDTH + \"px\";\r\n        slider.style.strokeDasharray = \"5, 2\";\r\n        slider.style.fill = \"#FFF\";\r\n\r\n        return slider;\r\n    }\r\n\r\n    /**\r\n     * Creates new SVG circle element based on passed options.\r\n     *\r\n     * @returns {SVGCircleElement}\r\n     */\r\n    [_createCircle]() {\r\n        const slider = document.createElementNS(SVG_NAMESPACE, 'circle');\r\n        slider.setAttributeNS(null, \"cx\", this.centerX);\r\n        slider.setAttributeNS(null, \"cy\", this.centerY);\r\n        slider.setAttributeNS(null, \"r\", this.radius);\r\n        slider.setAttributeNS(null, \"fill\", \"none\");\r\n\r\n        return slider;\r\n    }\r\n\r\n    /**\r\n     * Creates a handle for the slider.\r\n     */\r\n    [_createHandle]() {\r\n        const handle = document.createElementNS(SVG_NAMESPACE, 'circle');\r\n        handle.setAttributeNS(null, \"cx\", `${this.centerX}`);\r\n        handle.setAttributeNS(null, \"cy\", `${this.centerY - this.radius}`);\r\n        handle.setAttributeNS(null, \"r\", `${HANDLER_RADIUS}`);\r\n        handle.setAttributeNS(null, \"fill\", \"#fff\");\r\n        handle.setAttributeNS(null, \"class\", \"handle\");\r\n        handle.setAttributeNS(null, \"id\", \"handle\" + this.options.container + this.radius); // add uniqueId\r\n\r\n        return handle;\r\n    }\r\n\r\n    [_deg2Step](deg) {\r\n        const val = this[_deg2Val](deg);\r\n\r\n        return this[_val2Step](val);\r\n    }\r\n\r\n    [_deg2Val](deg) {\r\n        const range = this.options.max - this.options.min;\r\n\r\n        return Math.round(deg * (range / 360.0)) + this.options.min;\r\n    }\r\n\r\n    [_val2Step](val) {\r\n        return Math.round((val - this.options.min) / this.options.step)\r\n    }\r\n\r\n    [_step2Rad](stepNo) {\r\n        const val = stepNo * this.options.step + this.options.min;\r\n        const adjustedVal = val - this.options.min;\r\n        const range = this.options.max - this.options.min;\r\n        const degrees = this.options.max === val ? 359.99 : (Math.round(adjustedVal * (360.0 / range))) % 360;\r\n\r\n        return Math.round(degrees * Math.PI / 180 * 100) / 100;\r\n    }\r\n\r\n    [_point2Radians](x, y) {\r\n        // calculate distance from rotated circle (0° is on top)\r\n        // replacing x and y in Math.atan2 method rotates the axis for 90 degrees but in wrong direction\r\n        // multiply Y with -1 to \"rotate\" for 180° in the right direction :)\r\n        return Math.atan2(x - this.centerX, -y - this.centerY);\r\n    }\r\n\r\n    [_initEventHandlers]() {\r\n\r\n        this.container.addEventListener(\"mousemove\", e => this[_handleDrag](e));\r\n        this.container.addEventListener(\"mouseup\", e => this[_cancelDrag](e));\r\n        this.container.addEventListener(\"mouseleave\", e => this[_cancelDrag](e));\r\n\r\n        this.container.addEventListener(\"touchcancel\", e => this[_touchHandler](e));\r\n        this.container.addEventListener(\"touchend\", e => this[_touchHandler](e));\r\n\r\n        this.clickCircle.addEventListener('click', e => this[_handleSliderClick](e));\r\n        this.clickCircle.addEventListener(\"touchend\", e => this[_touchHandler](e));\r\n        this.clickCircle.addEventListener(\"touchstart\", e => this[_touchHandler](e));\r\n\r\n        this.slider.addEventListener('click', e => this[_handleSliderClick](e));\r\n        this.slider.addEventListener(\"touchend\", e => this[_touchHandler](e));\r\n        this.slider.addEventListener(\"touchstart\", e => this[_touchHandler](e));\r\n\r\n\r\n        this.handle.addEventListener(\"touchmove\", e => this[_touchHandler](e));\r\n        this.handle.addEventListener(\"touchstart\", e => this[_touchHandler](e));\r\n        this.handle.addEventListener(\"mousedown\", e => this[_startDrag](e));\r\n    }\r\n\r\n    [_startDrag](e) {\r\n        e.preventDefault();\r\n        this.isDragging = true;\r\n    };\r\n\r\n    /**\r\n     * Handles drag as long as the touch/mouse is inside the tolerance radius.\r\n     * @param e\r\n     */\r\n    [_handleDrag](e) {\r\n\r\n        e.preventDefault();\r\n        if (!this.isDragging) {\r\n            return;\r\n        }\r\n\r\n        const svgPoint = this.rootSVG.createSVGPoint();\r\n        const localCoords = this[_transformClientToLocalCoordinate](svgPoint, e);\r\n        const mouseHandleOffsetX = this.position.x - localCoords.x;\r\n        const mouseHandleOffsetY = this.position.y - localCoords.y;\r\n        if (mouseHandleOffsetX > TOLERANCE || mouseHandleOffsetY > TOLERANCE) {\r\n            this[_cancelDrag](e);\r\n        } else {\r\n            const angelRadians = this[_point2Radians](localCoords.x, localCoords.y);\r\n            this[_move](angelRadians);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cancels drag and finishes the move by scrolling to the closest step.\r\n     *\r\n     * @param e\r\n     */\r\n    [_cancelDrag](e) {\r\n        e.preventDefault();\r\n        this.options.eventType = e.type;\r\n        // only complete step if you are currently moving\r\n        if (this.isDragging) {\r\n            this.stepNo = this[_val2Step](this.value);\r\n        }\r\n\r\n        this.isDragging = false;\r\n        this.options.valueChange(this.currentValue, this.options.eventType);\r\n        this.options.eventType = '';\r\n    }\r\n\r\n    [_handleSliderClick](e) {\r\n        const svgPoint = this.rootSVG.createSVGPoint();\r\n        const localCoords = this[_transformClientToLocalCoordinate](svgPoint, e);\r\n        const newPosition = this[_calculateNewPosition](this[_point2Radians](localCoords.x, localCoords.y));\r\n        const nextStep = this[_deg2Step](newPosition.degrees);\r\n\r\n        if (this.currentStepNo === nextStep) {\r\n            this.handle.classList.add('same-step-error');\r\n            setTimeout(() => this.handle.classList.remove('same-step-error'), 300);\r\n        } else {\r\n            this.stepNo = nextStep;\r\n        }\r\n\r\n        this.options.eventType = e.type;\r\n    }\r\n\r\n    [_touchHandler](e) {\r\n        const touches = e.changedTouches;\r\n\r\n        // Ignore multi-touch\r\n        if (touches.length > 1) return;\r\n\r\n        const touch = touches[0];\r\n        const events = [\"touchstart\", \"touchmove\", \"touchend\", \"touchcancel\"];\r\n        const mouseEvents = [\"mousedown\", \"mousemove\", \"mouseup\", \"mouseleave\"];\r\n        const ev = events.indexOf(e.type);\r\n\r\n        if (ev === -1) return;\r\n\r\n        const type = e.type === events[2] && this.lastTouchType === events[0] ? 'click' : mouseEvents[ev];\r\n        const simulatedEvent = document.createEvent(\"MouseEvent\");\r\n        simulatedEvent.initMouseEvent(type, true, true, window, 1,\r\n            touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);\r\n\r\n        touch.target.dispatchEvent(simulatedEvent);\r\n        e.preventDefault();\r\n        this.lastTouchType = e.type;\r\n\r\n        this.options.eventType = e.type;\r\n    };\r\n\r\n    [_isIEorEdge]() {\r\n        return document.documentMode || navigator.appName === 'Microsoft Internet Explorer' || (navigator.appName === \"Netscape\" && navigator.appVersion.indexOf('Edge') > -1);\r\n    }\r\n}\r\n","/*! (C) Andrea Giammarchi - @WebReflection - ISC Style License */\n!function(e,t){\"use strict\";function n(){var e=A.splice(0,A.length);for(et=0;e.length;)e.shift().call(null,e.shift())}function r(e,t){for(var n=0,r=e.length;n<r;n++)T(e[n],t)}function o(e){for(var t,n=0,r=e.length;n<r;n++)t=e[n],V(t,ae[a(t)])}function l(e){return function(t){ke(t)&&(T(t,e),ie.length&&r(t.querySelectorAll(ie),e))}}function a(e){var t=Ge.call(e,\"is\"),n=e.nodeName.toUpperCase(),r=ce.call(le,t?ne+t.toUpperCase():te+n);return t&&-1<r&&!i(n,t)?-1:r}function i(e,t){return-1<ie.indexOf(e+'[is=\"'+t+'\"]')}function u(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,o=e.target,l=e[Q]||2,a=e[W]||3;!at||o&&o!==t||!t[j]||\"style\"===r||e.prevValue===e.newValue&&(\"\"!==e.newValue||n!==l&&n!==a)||t[j](r,n===l?null:e.prevValue,n===a?null:e.newValue)}function c(e){var t=l(e);return function(e){A.push(t,e.target),et&&clearTimeout(et),et=setTimeout(n,1)}}function s(e){lt&&(lt=!1,e.currentTarget.removeEventListener(J,s)),ie.length&&r((e.target||y).querySelectorAll(ie),e.detail===B?B:x),Ue&&p()}function m(e,t){var n=this;Xe.call(n,e,t),O.call(n,{target:n})}function f(e,t,n){var r=t.apply(e,n),l=a(r);return-1<l&&V(r,ae[l]),n.pop()&&ie.length&&o(r.querySelectorAll(ie)),r}function d(e,t){Se(e,t),I?I.observe(e,Ye):(ot&&(e.setAttribute=m,e[_]=D(e),e[k](ee,O)),e[k](Y,u)),e[X]&&at&&(e.created=!0,e[X](),e.created=!1)}function p(){for(var e,t=0,n=xe.length;t<n;t++)e=xe[t],ue.contains(e)||(n--,xe.splice(t--,1),T(e,B))}function h(e){throw new Error(\"A \"+e+\" type is already registered\")}function T(e,t){var n,r,o=a(e);-1<o&&!Ze.call(e,\"TEMPLATE\")&&(S(e,ae[o]),o=0,t!==x||e[x]?t!==B||e[B]||(e[x]=!1,e[B]=!0,r=\"disconnected\",o=1):(e[B]=!1,e[x]=!0,r=\"connected\",o=1,Ue&&ce.call(xe,e)<0&&xe.push(e)),o&&(n=e[t+q]||e[r+q])&&n.call(e))}function L(){}function M(e,t,n){var r=n&&n[Z]||\"\",o=t.prototype,l=Fe(o),a=t.observedAttributes||pe,i={prototype:l};_e(l,X,{value:function(){if(Ae)Ae=!1;else if(!this[He]){this[He]=!0,new t(this),o[X]&&o[X].call(this);var e=Oe[De.get(t)];(!be||e.create.length>1)&&H(this)}}}),_e(l,j,{value:function(e){-1<ce.call(a,e)&&o[j]&&o[j].apply(this,arguments)}}),o[z]&&_e(l,G,{value:o[z]}),o[K]&&_e(l,$,{value:o[K]}),r&&(i[Z]=r),e=e.toUpperCase(),Oe[e]={constructor:t,create:r?[r,Ie(e)]:[e]},De.set(t,e),y[R](e.toLowerCase(),i),g(e),Ne[e].r()}function E(e){var t=Oe[e.toUpperCase()];return t&&t.constructor}function v(e){return\"string\"==typeof e?e:e&&e.is||\"\"}function H(e){for(var t,n=e[j],r=n?e.attributes:pe,o=r.length;o--;)t=r[o],n.call(e,t.name||t.nodeName,null,t.value||t.nodeValue)}function g(e){return e=e.toUpperCase(),e in Ne||(Ne[e]={},Ne[e].p=new we(function(t){Ne[e].r=t})),Ne[e].p}function b(){ge&&delete e.customElements,de(e,\"customElements\",{configurable:!0,value:new L}),de(e,\"CustomElementRegistry\",{configurable:!0,value:L});for(var t=w.get(/^HTML[A-Z]*[a-z]/),n=t.length;n--;function(t){var n=e[t];if(n){e[t]=function(e){var t,r;return e||(e=this),e[He]||(Ae=!0,t=Oe[De.get(e.constructor)],r=be&&1===t.create.length,e=r?Reflect.construct(n,pe,t.constructor):y.createElement.apply(y,t.create),e[He]=!0,Ae=!1,r||H(e)),e},e[t].prototype=n.prototype;try{n.prototype.constructor=e[t]}catch(r){ve=!0,de(n,He,{value:e[t]})}}}(t[n]));y.createElement=function(e,t){var n=v(t);return n?We.call(this,e,Ie(n)):We.call(this,e)},tt||(rt=!0,y[R](\"\"))}var y=e.document,C=e.Object,w=function(e){var t,n,r,o,l=/^[A-Z]+[a-z]/,a=function(e){var t,n=[];for(t in u)e.test(t)&&n.push(t);return n},i=function(e,t){(t=t.toLowerCase())in u||(u[e]=(u[e]||[]).concat(t),u[t]=u[t.toUpperCase()]=e)},u=(C.create||C)(null),c={};for(n in e)for(o in e[n])for(r=e[n][o],u[o]=r,t=0;t<r.length;t++)u[r[t].toLowerCase()]=u[r[t].toUpperCase()]=o;return c.get=function(e){return\"string\"==typeof e?u[e]||(l.test(e)?[]:\"\"):a(e)},c.set=function(e,t){return l.test(e)?i(e,t):i(t,e),c},c}({collections:{HTMLAllCollection:[\"all\"],HTMLCollection:[\"forms\"],HTMLFormControlsCollection:[\"elements\"],HTMLOptionsCollection:[\"options\"]},elements:{Element:[\"element\"],HTMLAnchorElement:[\"a\"],HTMLAppletElement:[\"applet\"],HTMLAreaElement:[\"area\"],HTMLAttachmentElement:[\"attachment\"],HTMLAudioElement:[\"audio\"],HTMLBRElement:[\"br\"],HTMLBaseElement:[\"base\"],HTMLBodyElement:[\"body\"],HTMLButtonElement:[\"button\"],HTMLCanvasElement:[\"canvas\"],HTMLContentElement:[\"content\"],HTMLDListElement:[\"dl\"],HTMLDataElement:[\"data\"],HTMLDataListElement:[\"datalist\"],HTMLDetailsElement:[\"details\"],HTMLDialogElement:[\"dialog\"],HTMLDirectoryElement:[\"dir\"],HTMLDivElement:[\"div\"],HTMLDocument:[\"document\"],HTMLElement:[\"element\",\"abbr\",\"address\",\"article\",\"aside\",\"b\",\"bdi\",\"bdo\",\"cite\",\"code\",\"command\",\"dd\",\"dfn\",\"dt\",\"em\",\"figcaption\",\"figure\",\"footer\",\"header\",\"i\",\"kbd\",\"mark\",\"nav\",\"noscript\",\"rp\",\"rt\",\"ruby\",\"s\",\"samp\",\"section\",\"small\",\"strong\",\"sub\",\"summary\",\"sup\",\"u\",\"var\",\"wbr\"],HTMLEmbedElement:[\"embed\"],HTMLFieldSetElement:[\"fieldset\"],HTMLFontElement:[\"font\"],HTMLFormElement:[\"form\"],HTMLFrameElement:[\"frame\"],HTMLFrameSetElement:[\"frameset\"],HTMLHRElement:[\"hr\"],HTMLHeadElement:[\"head\"],HTMLHeadingElement:[\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\"],HTMLHtmlElement:[\"html\"],HTMLIFrameElement:[\"iframe\"],HTMLImageElement:[\"img\"],HTMLInputElement:[\"input\"],HTMLKeygenElement:[\"keygen\"],HTMLLIElement:[\"li\"],HTMLLabelElement:[\"label\"],HTMLLegendElement:[\"legend\"],HTMLLinkElement:[\"link\"],HTMLMapElement:[\"map\"],HTMLMarqueeElement:[\"marquee\"],HTMLMediaElement:[\"media\"],HTMLMenuElement:[\"menu\"],HTMLMenuItemElement:[\"menuitem\"],HTMLMetaElement:[\"meta\"],HTMLMeterElement:[\"meter\"],HTMLModElement:[\"del\",\"ins\"],HTMLOListElement:[\"ol\"],HTMLObjectElement:[\"object\"],HTMLOptGroupElement:[\"optgroup\"],HTMLOptionElement:[\"option\"],HTMLOutputElement:[\"output\"],HTMLParagraphElement:[\"p\"],HTMLParamElement:[\"param\"],HTMLPictureElement:[\"picture\"],HTMLPreElement:[\"pre\"],HTMLProgressElement:[\"progress\"],HTMLQuoteElement:[\"blockquote\",\"q\",\"quote\"],HTMLScriptElement:[\"script\"],HTMLSelectElement:[\"select\"],HTMLShadowElement:[\"shadow\"],HTMLSlotElement:[\"slot\"],HTMLSourceElement:[\"source\"],HTMLSpanElement:[\"span\"],HTMLStyleElement:[\"style\"],HTMLTableCaptionElement:[\"caption\"],HTMLTableCellElement:[\"td\",\"th\"],HTMLTableColElement:[\"col\",\"colgroup\"],HTMLTableElement:[\"table\"],HTMLTableRowElement:[\"tr\"],HTMLTableSectionElement:[\"thead\",\"tbody\",\"tfoot\"],HTMLTemplateElement:[\"template\"],HTMLTextAreaElement:[\"textarea\"],HTMLTimeElement:[\"time\"],HTMLTitleElement:[\"title\"],HTMLTrackElement:[\"track\"],HTMLUListElement:[\"ul\"],HTMLUnknownElement:[\"unknown\",\"vhgroupv\",\"vkeygen\"],HTMLVideoElement:[\"video\"]},nodes:{Attr:[\"node\"],Audio:[\"audio\"],CDATASection:[\"node\"],CharacterData:[\"node\"],Comment:[\"#comment\"],Document:[\"#document\"],DocumentFragment:[\"#document-fragment\"],DocumentType:[\"node\"],HTMLDocument:[\"#document\"],Image:[\"img\"],Option:[\"option\"],ProcessingInstruction:[\"node\"],ShadowRoot:[\"#shadow-root\"],Text:[\"#text\"],XMLDocument:[\"xml\"]}});\"object\"!=typeof t&&(t={type:t||\"auto\"});var A,O,N,D,I,F,S,V,P,R=\"registerElement\",U=1e5*e.Math.random()>>0,_=\"__\"+R+U,k=\"addEventListener\",x=\"attached\",q=\"Callback\",B=\"detached\",Z=\"extends\",j=\"attributeChanged\"+q,G=x+q,z=\"connected\"+q,K=\"disconnected\"+q,X=\"created\"+q,$=B+q,Q=\"ADDITION\",W=\"REMOVAL\",Y=\"DOMAttrModified\",J=\"DOMContentLoaded\",ee=\"DOMSubtreeModified\",te=\"<\",ne=\"=\",re=/^[A-Z][._A-Z0-9]*-[-._A-Z0-9]*$/,oe=[\"ANNOTATION-XML\",\"COLOR-PROFILE\",\"FONT-FACE\",\"FONT-FACE-SRC\",\"FONT-FACE-URI\",\"FONT-FACE-FORMAT\",\"FONT-FACE-NAME\",\"MISSING-GLYPH\"],le=[],ae=[],ie=\"\",ue=y.documentElement,ce=le.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},se=C.prototype,me=se.hasOwnProperty,fe=se.isPrototypeOf,de=C.defineProperty,pe=[],he=C.getOwnPropertyDescriptor,Te=C.getOwnPropertyNames,Le=C.getPrototypeOf,Me=C.setPrototypeOf,Ee=!!C.__proto__,ve=!1,He=\"__dreCEv1\",ge=e.customElements,be=!/^force/.test(t.type)&&!!(ge&&ge.define&&ge.get&&ge.whenDefined),ye=C.create||C,Ce=e.Map||function(){var e,t=[],n=[];return{get:function(e){return n[ce.call(t,e)]},set:function(r,o){e=ce.call(t,r),e<0?n[t.push(r)-1]=o:n[e]=o}}},we=e.Promise||function(e){function t(e){for(r=!0;n.length;)n.shift()(e)}var n=[],r=!1,o={\"catch\":function(){return o},then:function(e){return n.push(e),r&&setTimeout(t,1),o}};return e(t),o},Ae=!1,Oe=ye(null),Ne=ye(null),De=new Ce,Ie=function(e){return e.toLowerCase()},Fe=C.create||function ct(e){return e?(ct.prototype=e,new ct):this},Se=Me||(Ee?function(e,t){return e.__proto__=t,e}:Te&&he?function(){function e(e,t){for(var n,r=Te(t),o=0,l=r.length;o<l;o++)n=r[o],me.call(e,n)||de(e,n,he(t,n))}return function(t,n){do{e(t,n)}while((n=Le(n))&&!fe.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),Ve=e.MutationObserver||e.WebKitMutationObserver,Pe=e.HTMLAnchorElement,Re=(e.HTMLElement||e.Element||e.Node).prototype,Ue=!fe.call(Re,ue),_e=Ue?function(e,t,n){return e[t]=n.value,e}:de,ke=Ue?function(e){return 1===e.nodeType}:function(e){return fe.call(Re,e)},xe=Ue&&[],qe=Re.attachShadow,Be=Re.cloneNode,Ze=Re.closest||function(e){for(var t=this;t&&t.nodeName!==e;)t=t.parentNode;return t},je=Re.dispatchEvent,Ge=Re.getAttribute,ze=Re.hasAttribute,Ke=Re.removeAttribute,Xe=Re.setAttribute,$e=y.createElement,Qe=y.importNode,We=$e,Ye=Ve&&{attributes:!0,characterData:!0,attributeOldValue:!0},Je=Ve||function(e){ot=!1,ue.removeEventListener(Y,Je)},et=0,tt=R in y&&!/^force-all/.test(t.type),nt=!0,rt=!1,ot=!0,lt=!0,at=!0;if(Ve&&(P=y.createElement(\"div\"),P.innerHTML=\"<div><div></div></div>\",new Ve(function(e,t){if(e[0]&&\"childList\"==e[0].type&&!e[0].removedNodes[0].childNodes.length){P=he(Re,\"innerHTML\");var n=P&&P.set;n&&de(Re,\"innerHTML\",{set:function(e){for(;this.lastChild;)this.removeChild(this.lastChild);n.call(this,e)}})}t.disconnect(),P=null}).observe(P,{childList:!0,subtree:!0}),P.innerHTML=\"\"),tt||(Me||Ee?(S=function(e,t){fe.call(t,e)||d(e,t)},V=d):(S=function(e,t){e[_]||(e[_]=C(!0),d(e,t))},V=S),Ue?(ot=!1,function(){var e=he(Re,k),t=e.value,n=function(e){var t=new CustomEvent(Y,{bubbles:!0});t.attrName=e,t.prevValue=Ge.call(this,e),t.newValue=null,t[W]=t.attrChange=2,Ke.call(this,e),je.call(this,t)},r=function(e,t){var n=ze.call(this,e),r=n&&Ge.call(this,e),o=new CustomEvent(Y,{bubbles:!0});Xe.call(this,e,t),o.attrName=e,o.prevValue=n?r:null,o.newValue=t,n?o.MODIFICATION=o.attrChange=1:o[Q]=o.attrChange=0,je.call(this,o)},o=function(e){var t,n=e.currentTarget,r=n[_],o=e.propertyName;r.hasOwnProperty(o)&&(r=r[o],t=new CustomEvent(Y,{bubbles:!0}),t.attrName=r.name,t.prevValue=r.value||null,t.newValue=r.value=n[o]||null,null==t.prevValue?t[Q]=t.attrChange=0:t.MODIFICATION=t.attrChange=1,je.call(n,t))};e.value=function(e,l,a){e===Y&&this[j]&&this.setAttribute!==r&&(this[_]={className:{name:\"class\",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,\"propertychange\",o)),t.call(this,e,l,a)},de(Re,k,e)}()):Ve||(ue[k](Y,Je),ue.setAttribute(_,1),ue.removeAttribute(_),ot&&(O=function(e){var t,n,r,o=this;if(o===e.target){t=o[_],o[_]=n=D(o);for(r in n){if(!(r in t))return N(0,o,r,t[r],n[r],Q);if(n[r]!==t[r])return N(1,o,r,t[r],n[r],\"MODIFICATION\")}for(r in t)if(!(r in n))return N(2,o,r,t[r],n[r],W)}},N=function(e,t,n,r,o,l){var a={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:o};a[l]=e,u(a)},D=function(e){for(var t,n,r={},o=e.attributes,l=0,a=o.length;l<a;l++)t=o[l],\"setAttribute\"!==(n=t.name)&&(r[n]=t.value);return r})),y[R]=function(e,t){if(n=e.toUpperCase(),nt&&(nt=!1,Ve?(I=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new Ve(function(r){for(var o,l,a,i=0,u=r.length;i<u;i++)o=r[i],\"childList\"===o.type?(n(o.addedNodes,e),n(o.removedNodes,t)):(l=o.target,at&&l[j]&&\"style\"!==o.attributeName&&(a=Ge.call(l,o.attributeName))!==o.oldValue&&l[j](o.attributeName,o.oldValue,a))})}(l(x),l(B)),F=function(e){return I.observe(e,{childList:!0,subtree:!0}),e},F(y),qe&&(Re.attachShadow=function(){return F(qe.apply(this,arguments))})):(A=[],y[k](\"DOMNodeInserted\",c(x)),y[k](\"DOMNodeRemoved\",c(B))),y[k](J,s),y[k](\"readystatechange\",s),y.importNode=function(e,t){switch(e.nodeType){case 1:return f(y,Qe,[e,!!t]);case 11:for(var n=y.createDocumentFragment(),r=e.childNodes,o=r.length,l=0;l<o;l++)n.appendChild(y.importNode(r[l],!!t));return n;default:return Be.call(e,!!t)}},Re.cloneNode=function(e){return f(this,Be,[!!e])}),rt)return rt=!1;if(-2<ce.call(le,ne+n)+ce.call(le,te+n)&&h(e),!re.test(n)||-1<ce.call(oe,n))throw new Error(\"The type \"+e+\" is invalid\");var n,o,a=function(){return u?y.createElement(m,n):y.createElement(m)},i=t||se,u=me.call(i,Z),m=u?t[Z].toUpperCase():n;return u&&-1<ce.call(le,te+m)&&h(m),o=le.push((u?ne:te)+n)-1,ie=ie.concat(ie.length?\",\":\"\",u?m+'[is=\"'+e.toLowerCase()+'\"]':m),a.prototype=ae[o]=me.call(i,\"prototype\")?i.prototype:Fe(Re),ie.length&&r(y.querySelectorAll(ie),x),a},y.createElement=We=function(e,t){var n=v(t),r=n?$e.call(y,e,Ie(n)):$e.call(y,e),o=\"\"+e,l=ce.call(le,(n?ne:te)+(n||o).toUpperCase()),a=-1<l;return n&&(r.setAttribute(\"is\",n=n.toLowerCase()),a&&(a=i(o.toUpperCase(),n))),at=!y.createElement.innerHTMLHelper,a&&V(r,ae[l]),r}),addEventListener(\"beforeunload\",function(){delete y.createElement,delete y.importNode,delete y[R]},!1),L.prototype={constructor:L,define:be?function(e,t,n){if(n)M(e,t,n);else{var r=e.toUpperCase();Oe[r]={constructor:t,create:[r]},De.set(t,r),ge.define(e,t)}}:M,get:be?function(e){return ge.get(e)||E(e)}:E,whenDefined:be?function(e){return we.race([ge.whenDefined(e),g(e)])}:g},!ge||/^force/.test(t.type))b();else if(!t.noBuiltIn)try{!function(t,n,r){var o=new RegExp(\"^<a\\\\s+is=('|\\\")\"+r+\"\\\\1></a>$\");if(n[Z]=\"a\",t.prototype=Fe(Pe.prototype),t.prototype.constructor=t,e.customElements.define(r,t,n),!o.test(y.createElement(\"a\",{is:r}).outerHTML)||!o.test((new t).outerHTML))throw n}(function st(){return Reflect.construct(Pe,[],st)},{},\"document-register-element-a\"+U)}catch(it){b()}if(!t.noBuiltIn)try{if($e.call(y,\"a\",\"a\").outerHTML.indexOf(\"is\")<0)throw{}}catch(ut){Ie=function(e){return{is:e.toLowerCase()}}}}(window);\n"],"sourceRoot":"webpack:///"}